---
title: JS原生-JS事件循环机制
tags:
  - 学习
date: 2023-6-30
author: Eric
comments: false
cover: /img/13.jpeg
index_enable: true #是否显示文章封面
aside_enable: true #侧栏是否显示文章封面图s
archives_enable: true
position: both #封面显示的位置# 三个值可配置left , right , both
---

### JS 事件循环机制

#### 进程和线程

> 线程和进程是操作系统中的两个概念
>
> - 进程（process）: 计算机已经运行的程序，是操作系统管理程序的一种方式
>
> - 线程（thread）: 操作系统能够运行运算调度的最小单位，通常情况下他被包含在进程中
>
> - 进程：可以认为，启动一个应用程序，就会默认启动一个进程（也可以十多个进程）
>
> - 线程：每一个进程中，都会启动至少一个线程给你用来执行程序中的代码，这个线程被称为主线程：所以我们也说进程是线程的容器

### 操作系统-进程-线程

![](/images/JS远程/1-1.png)

### 操作系统的工作方式

> 操作系统是如何做到同时让多个线程同时工作的
>
> - 这是因为 CPU 的运算速度非常快，它可以快速的在多个进程中迅速的切换
>
> - 当我们进程中的线程获取到的时间片时，就可以快速执行我们编写的代码
>
> - 对于用户来说感受不到快速的切换

### 浏览器中的 JS 线程

> JS 是单线程语言，但是 JS 的线程有自己的容器进程：浏览器/Node
>
> JS 的代码执行实在一个单独的线程中执行的：
>
> - 这就意味着 JS 的代码，同一时间只能做一件事
> - 如果这件事是非常耗时的，就意味着当前的线程就会被阻塞
>
> 所以真正耗时的操作，其实并不是由 JS 线程在执行
>
> - 浏览器的每个进程是多线程，那么其他线程可以完成这个耗时的操作
> - 比如网络请求、定时器，我们只需要在特性的时候执行应该有的回调即可

### 事件循环

> JS 有一个基于事件循环的并发模型，事件循环负责执行代码、手机和处理事件以及执行队列中的子任务。这个模式与其他语言中的模型截然不同，比如 C 和 JAVA。简单来说，对于 JS 运行中的任务，JS 有一套处理收集，排队，执行的特殊机制，我们把这套处理机制称为事件循环（Event Loop）

### 单线程

> JS 单线程指的是 javascript 引擎（如 V8）在同一时刻只能处理一个任务
> JS 单线程和异步任务 ajax 的执行并不冲突，ajax 等异步任务不是在 JS 引擎上运行的，ajax 在浏览器处理网络的模块中执行，此时不会影响到 JS 引擎的任务处理

### 执行环境

> 执行环境是 JS 代码语句执行的环境，包含全局执行环境和函数执行环境
>
> - 全局执行环境：全局环境是最外围的一个执行环境，根据 ECMAScript 实现所在的宿主环境不同，表示执行环境的对象也不一样，在 web 中，全局执行环境被认定为是 window 对象。
> - 函数执行环境：每个函数都有自己的执行环境
>
> 当一个任务执行时，相应的会对应一个动态变化的执行环境栈，这个执行环境栈包括了不同的执行环境，是一个后进先出的结构

### 变量对象

> 每个执行环境都有一个变量对象与之相关联（一一对应），变量对象包含额执行环境中定义的所有变量及函数，我们在代码中尽量少创建全局白能量，就是因为全局环境对应的白能量对象一直会存在内存中。

### 浏览器内核中各个线程之间的关系

![](/images/JS远程/1-2.png)

### 浏览器内核中有多种线程在工作

- GUI 渲染线程
  - 负责渲染页面，解析 HTML，CSS 构成 DOM 树等，当页面重回或者由于某种操作引起回流都会调起该线程
  - 和 JS 引擎线程是互斥的，当 JS 引擎线程在工作的时候，GUI 渲染线程会被挂起，GUI 更新会被放入到 JS 任务队列中，等待 JS 引擎线程空闲的时候继续执行
- JS 引擎线程
  - 单线程工作，负责解析运行 Javascript 脚本
  - 和 GUI 渲染线程互斥，JS 运行耗时过长就会导致页面阻塞
- 事件触发线程
  - 当事件符合触发条件被触发时，该线程就会把对应的事件回调函数添加到任务队列的队尾，等待 JS 引擎处理
- 定时器触发线程
  - 浏览器定时计时器并不是由 JS 引擎计数，阻塞会导致计时不准确
  - 开启定时器触发线程来计时并触发计时，计时完成后会被添加到任务队列中，等待 JS 引擎处理
- http 请求线程
  - http 请求的时候会开启一条请求线程
  - 请求完成有结果之后，将请求的回调函数添加到任务队列中国，等待 JS 引擎处理

### JavaScript 事件循环机制

> JavaScript 事件循环机制分为浏览器和 Node 事件循环机制，两者的实现技术不一样，浏览器 Event Loop 是 HTML 中定义的规范，Node Event Loop 是由 libuv 库实现。这里主要讲的是浏览器部分。
> Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。

### JS 调用栈

> JS 调用栈是一种后进先出的数据结构。当函数被调用时，会被添加到栈中的顶部，执行完成后就会重栈顶部移出该函数，直到栈内被清空

### 同步任务、异步任务

> JavaScript 单线程中的任务分为同步任务和异步任务。同步任务会在调用栈中按照顺序排队等待主线程执行，异步任务则会在异步有了结果后将注册的回调函数添加到任务队列(消息队列)中等待主线程空闲的时候，也就是栈内被清空的时候，被读取到栈中等待主线程执行。任务队列是先进先出的数据结构。

### Event Loop

> 调用栈中的同步任务都执行完毕，栈内被清空了，就代表主线程空闲了，这个时候就会去任务队列中按照顺序读取一个任务放入到栈中执行。每次栈内被清空，都会去读取任务队列有没有任务，有就读取执行，一直循环读取-执行的操作，就形成了事件循环。

### 定时器

> 定时器会开启一条定时器触发线程来触发计时，定时器会在等待了指定的时间后将事件放入到任务队列中等待读取到主线程执行。
> 定时器指定的延时毫秒数其实并不准确，因为定时器只是在到了指定的时间时将事件放入到任务队列中，必须要等到同步的任务和现有的任务队列中的事件全部执行完成之后，才会去读取定时器的事件到主线程执行，中间可能会存在耗时比较久的任务，那么就不可能保证在指定的时间执行。

### 宏任务(macro-task)、微任务(micro-task)

> 除了广义的同步任务和异步任务，JavaScript 单线程中的任务可以细分为宏任务和微任务。
>
> - 宏任务（macro-task）：一般是 JS 引擎和宿主环境发生通信产生的回调任务，比如 setTimeout，setInterval 是浏览器进行计时的，其中回调函数的执行时间需要浏览器通知到 JS 引擎，网络模块, I/O 处理的通信回调也是。包含有 setTimeout，setInterval，DOM 事件回调，ajax 请求结束后的回调，整体 script 代码，setImmediate（node.js 主要是）
>
> - 微任务（micro-task）：一般是宏任务在线程中执行时产生的回调，如 Promise，process.nextTick，Object.observe(已废弃)， MutationObserver（DOM 监听），这些都是 JS 引擎自身可以监听到回调。
>
> - 上面我们了解了宏任务与微任务的分类，那么为什么我们要将其分为宏任务与微任务呢？主要是因为其添加到事件循环中的任务队列的机制不同。
>
> 在事件循环中，任务一般都是由宏任务开始执行的（JS 代码的加载执行），在宏任务的执行过程中，可能会产生新的宏任务和微任务，这时候宏任务（如 ajax 回调）会被添加到任务队列的末尾等待事件循环机制执行，而微任务则会被添加到当前任务队列的前端，也是等待事件循环机制的执行。
>
> ​ 其中相同类型的宏任务或微任务会按照回调的先后顺序进行排序，而不同任务类型的任务会有一定的优先级，按照不同类型任务区分

### 宏任务优先级

主代码块 > setImmediate > MessageChannel > setTimeout > setInterval

### 微任务优先级

process.nextTick > Promise > MutationObserver
